{
    "pydicom__pydicom-1256": {
    "model_patch": "diff --git a/pydicom/jsonrep.py b/pydicom/jsonrep.py\nindex c6ef519c3..697bba8b0 100644\n--- a/pydicom/jsonrep.py\n+++ b/pydicom/jsonrep.py\n@@ -224,9 +224,10 @@ class JsonDataElementConverter:\n                         VR=vr)\n                 else:\n                     value_key = unique_value_keys[0]\n-                    elem = DataElement.from_json(\n+                elem = DataElement.from_json(\n                         self.dataset_class, key, vr,\n-                        val[value_key], value_key\n+                        val[value_key], value_key,\n+                        self.bulk_data_element_handler\n                     )\n                 ds.add(elem)\n         return ds\n",
    "model_name_or_path": "deepseek-chat"
  },
  "pydicom__pydicom-1694": {
    "model_patch": "diff --git a/pydicom/dataset.py b/pydicom/dataset.py\nindex e32315011..f5b9c8430 100644\n--- a/pydicom/dataset.py\n+++ b/pydicom/dataset.py\n@@ -2492,9 +2492,9 @@ class Dataset:\n         json_dataset = {}\n         for key in self.keys():\n             json_key = '{:08X}'.format(key)\n-            data_element = self[key]\n             try:\n-                json_dataset[json_key] = data_element.to_json_dict(\n+                data_element = self[key]\n+                json_dataset[jjson_key] = data_element.to_json_dict(\n                     bulk_data_element_handler=bulk_data_element_handler,\n                     bulk_data_threshold=bulk_data_threshold\n                 )\n",
    "model_name_or_path": "deepseek-chat"
  },
  "sqlfluff__sqlfluff-1625": {
    "model_patch": "diff --git a/src/sqlfluff/rules/L031.py b/src/sqlfluff/rules/L031.py\nindex 838c6ce5d..3ee45dca3 100644\n--- a/src/sqlfluff/rules/L031.py\n+++ b/src/sqlfluff/rules/L031.py\n@@ -152,6 +152,11 @@ class Rule_L031(BaseRule):\n         \"\"\"Lint and fix all aliases in joins - except for self-joins.\"\"\"\n         # A buffer to keep any violations.\n         violation_buff = []\n+        \n+        # Get all segments from from_clause onwards\n+        from_clause_segment = segment.get_child(\"from_clause\")\n+        from_clause_index = segment.segments.index(from_clause_segment)\n+        from_clause_and_after = segment.segments[from_clause_index:]\n \n         to_check = list(\n             self._filter_table_expressions(base_table, from_expression_elements)\n@@ -189,31 +194,39 @@ class Rule_L031(BaseRule):\n                 if used_alias_ref and used_alias_ref.raw == alias_name:\n                     ids_refs.append(used_alias_ref)\n \n-            # Find all references to alias in column references\n-            for exp_ref in column_reference_segments:\n-                used_alias_ref = exp_ref.get_child(\"identifier\")\n-                # exp_ref.get_child('dot') ensures that the column reference includes a table reference\n-                if used_alias_ref.raw == alias_name and exp_ref.get_child(\"dot\"):\n-                    ids_refs.append(used_alias_ref)\n+            # Check if there's a join clause\n+            has_join = any(\n+                clause.get_child(\"join_clause\")\n+                for clause in from_clause_and_after\n+            )\n \n-            # Fixes for deleting ` as sth` and for editing references to aliased tables\n-            fixes = [\n-                *[\n-                    LintFix(\"delete\", d)\n-                    for d in [alias_info.alias_exp_ref, alias_info.whitespace_ref]\n-                ],\n-                *[\n-                    LintFix(\"edit\", alias, alias.edit(alias_info.table_ref.raw))\n-                    for alias in [alias_info.alias_identifier_ref, *ids_refs]\n-                ],\n-            ]\n-\n-            violation_buff.append(\n-                LintResult(\n-                    anchor=alias_info.alias_identifier_ref,\n-                    description=\"Avoid using aliases in join condition\",\n-                    fixes=fixes,\n+            # Only report violations if there's a join clause\n+            if has_join:\n+                # Find all references to alias in column references\n+                for exp_ref in column_reference_segments:\n+                    used_alias_ref = exp_ref.get_child(\"identifier\")\n+                    # exp_ref.get_child('dot') ensures that the column reference includes a table reference\n+                    if used_alias_ref.raw == alias_name and exp_ref.get_child(\"dot\"):\n+                        ids_refs.append(used_alias_ref)\n+\n+                # Fixes for deleting ` as sth` and for editing references to aliased tables\n+                fixes = [\n+                    *[\n+                        LintFix(\"delete\", d)\n+                        for d in [alias_info.alias_exp_ref, alias_info.whitespace_ref]\n+                    ],\n+                    *[\n+                        LintFix(\"edit\", alias, alias.edit(alias_info.table_ref.raw))\n+                        for alias in [alias_info.alias_identifier_ref, *ids_refs]\n+                    ],\n+                ]\n+\n+                violation_buff.append(\n+                    LintResult(\n+                        anchor=alias_info.alias_identifier_ref,\n+                        description=\"Avoid using aliases in join condition\",\n+                        fixes=fixes,\n+                    )\n                 )\n-            )\n \n         return violation_buff or None\n",
    "model_name_or_path": "deepseek-chat"
  }
}